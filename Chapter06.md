# 📚 Chapter 06. DI(Dependency Injection)와 서비스 로케이터
## 어플리케이션 영역와 메인 영역
- 어플리케이션 영역: 고수준 정책 및 저수준 구현을 포함한 영역(인터페이스와 콘크리트 클래스 등)
- 메인 영역: `fun main()`에 속한 영역

### Locator를 알아보자
- 설계도를 보면 추상 타입과 콘크리트 클래스를 활용함 -> 개방 폐쇄 원칙 + 의존 역전 원칙
- 근데 어디서 콘크리트 클래스를 생성하지??

> Locator 사용 전 코드 구성  
![locator사용전](https://user-images.githubusercontent.com/95393311/155847421-3a1ebfc6-5f65-46e9-a43b-b4c14467fb01.JPG)

- Locator 사용 전
  - 콘크리트 클래스를 직접 생성 및 설정해야 한다.

> Locator 사용 후 + Locator 코드 구성 + 설계도  
![locator사용후](https://user-images.githubusercontent.com/95393311/155847425-c4317ef9-6127-474e-b1b2-7101edee1822.JPG)
![locator코드구성](https://user-images.githubusercontent.com/95393311/155847430-acd26485-925a-44db-ad0a-bdbf41ce6d54.JPG)

- Locator 사용 후 + Locator 코드 구성 + 설계도
    - Locator를 통해 콘크리트 클래스를 생성 및 설정한다.
    - Locator를 같은 패키지에 넣지 않을 경우, 순환 의존이 발생하게 된다
      (Work(transcoder 패키지) -> Locator(locator 패키지) -> JobQueue + TransCorder (transcoder 패키지) 
    

### 메인 영역의 역할
- 어플리케이션 영역에서 사용될 객체를 생성한다
- 각 객체 간의 의존 관계를 설정한다.
- 어플리케이션을 실행한다.

> 어플리케이션 영역의 객체를 `생성`, `설정` 하고 `실행`하는 책임을 가짐

### 메인 영역의 코드 구성
> 메인 영역의 코드 구성  
![메인영역](https://user-images.githubusercontent.com/95393311/155847444-c7fecd1f-4480-4c4b-b870-5d1cc27e5bdb.JPG)

#### 장점
- 각각 다른 콘크리트 클래스를 사용하고 싶다면 어플리케이션 영역은 수정할 필요 없이 메인 영역에서만 코드를 수정하면 된다
- 모든 의존은 메인 영역 -> 어플리케이션 영역이다
  - 즉, 메인 영역을 수정해도 어플리케이션 영역에는 영향이 미치지 않는다.

> 이처럼 사용할 객체를 제공하는 책임을 갖는 객체를 서비스 로케이터(Service Locator)라 한다

## DI를 이용한 의존 객체 사용
- 사용할 객체를 직접 생성하게 되면 콘크리트 클래스에 대한 의존이 발생
  - 이는 의존 역전 + 개방 폐쇄 원칙 위반
  - 유연하지 못한 코드 구성임
```
class Worker {

    fun run() {
        val jobQueue: JobQueue = JobQueue 클래스의 콘크리트 클래스 중 하나 // JobQueue를 구한다

}
```

- 이를 해결할 방안으로 서비스 로케이터를 사용할 수 있는데, 서비스 로케이터의 경우에도 몇 가지 단점이 있음 (이 부분은 이후에 설명)
- 위에서 말한 단점들을 극복하고 보완하는 방법이 DI (Dependency Injection: 의존 주입)
## DI 사용하는 방법
> 생성자를 통한 의존성 주입  
![DI_생성자](https://user-images.githubusercontent.com/95393311/155847456-5801365a-b567-4541-b838-60c361c2f641.JPG)

- 간단하게 생성자를 통해 사용할 객체를 전달받을 수 있다
- 각 구현 클래스는 Worker 객체나 JobCLI 객체에서 찾거나 생성하지 않고, 메인 영역에서 생성자를 통해 주입하고 있다.
- 이처럼 누군가 외부에서 의존하는 객체를 넣어주기 때문에 의존(dependency) 주입(injection)이라 부른다

### main()이 아니라 조립 역할 하는 클래스 분리

> 조립기 클래스를 분리한 후, 조립기 클래스 코드 구성과 main() 코드  
![DI_생성자_조립기](https://user-images.githubusercontent.com/95393311/155847532-fddc7323-675d-412f-ba70-dd08507ca33c.JPG)
- DI를 통해서 의존 객체를 관리할 때는 객체를 생성하고 이를 의존 관계에 따라 연결해 주는 조립 기능이 필요
- main() 함수의 조립 기능을 조립기 클래스로 분리해서, 조립기 구현 변경의 유연함을 얻을 수 있다.
  - Assemble 클래스를 통해 어플리케이션 영역에서 사용할 객체를 생성하고 생성자를 통해 의존 객체를 전달
  - main() 함수는 Assmeble에게 객체 생성과 조립 책임을 위임
- 스프링 프레임워크가 객체를 생성하고 조립 해주는 기능을 제공하는 대표적인 DI 프레임워크


## DI 방식
1. 생성자 방식
2. 설정 메서드 방식

### 설정 메서드 방식
> 설정 메서드 방식의 구현  
![DI_설정메서드](https://user-images.githubusercontent.com/95393311/155847473-f8821a95-8651-4b4a-abb1-8398579db95d.JPG)


> 다양한 방식으로 설정 메서드 구현  
![다양한설정메서드](https://user-images.githubusercontent.com/95393311/155847478-2875b2bd-76c2-4dcd-8c9b-f1979418245f.JPG)

## 각 방식의 장단점
1. 생성자 방식
   - 저자가 선호하는 방식
   - 객체를 생성하는 시점에 의존 객체가 정상인지 확인할 수 있다. (예외 처리가 수월해짐)
     - 즉, 예외없이 객체가 생성되면 정상적으로 동작함을 보장할 수 있게 된다.
   - Immutable 가능 (val)
     - 설정 메서드 방식은 설정 메서드를 써서 의존 객체를 생성하기 때문에 mutable 타입이어야 한다 (var) 

2. 설정 메서드 방식
   - 어떤 이유로 의존할 객체를 나중에 생성해야 한다면 설정 메서드 방식이 유용
   - 의존 객체가 많을 경우, 메서드 이름을 통해 어떤 의존 객체를 설정하고 있는지 파악할 수 있어 가독성이 높음

## DI와 테스트
- 추상 타입을 활용했기 때문에 콘크리트 클래스가 없더라도 테스트가 가능하다
  - DI 패턴을 사용하면 Mock 객체를 쉽게 전달할 수 있다.
- DI 패턴을 사용하지 않는다면?
  - 테스트하기 위해 추상 타입의 클래스가 Mock 객체를 반환하도록 코드를 수정해야 함
  - 테스트가 끝나면 이를 다시 반환값을 추상 타입으로 변경해야 함


#### 스프링 프레임워크 예

## 서비스 로케이터를 이용한 의존 객체 사용
- 서비스 로케이터는 메인 영역이 아니라 어플리케이션 영역에 직접 접근
- 메인 영역에서는 서비스 로케이터를 생성하하고 이 객체로 초기화를 진행

## 서비스 로케이터 구현 방식

> 객체 등록 방식  
![객체등록방식](https://user-images.githubusercontent.com/95393311/155847488-3937ba15-5ff0-450d-ba33-3cc7643576e0.JPG)  

### 객체 등록 방식을 통한 구현
1. 서비스 로케이터를 생성할 때 사용할 객체를 전달
2. 서비스 로케이터 인스턴스를 지정하고 참조하기 위한 static (companion object) 메서드를 제공 (이걸 하지 않으면 메인 영역에 로케이터를 등록할 수 없음 -> 의존 역전과 개방 폐쇄 원칙 위반)
3. 이 방식은 서비스 로케이터 구현이 쉽다는 장점이 있다
4. 하지만 이 방법은 인터페이스가 노출되어 있기 때문에 어플리케이션 영역에서 의존 객체를 바꿀 수 있다.


### 상속을 통한 구현
1. 객체를 구하는 추상 메서드를 제공하는 상위 타입 구현
2. 상위 타입을 상속받은 하위 타입에서 사용할 객체 설정

### 지네릭/템플릿을 이용한 구현
1. 서비스 로케이터의 단점은 인터페이스 분리 원칙을 위반한다는 점
2. 하지만 제네릭 타입을 활용해서 어느 정도 인터페이스 분리 원칙을 지키는 효과를 볼 수 있음

## 서비스 로케이터의 단점
1. 동일 타입의 객체가 다수 필요할 경우, 각 객체 별로 제공 메서드를 만들어 주어야 함
2. 인터페이스 분리 원칙을 위반

> 결론 서비스 로케이터 보다는 DI를 사용하자

## 추가 학습 거리
- 안드로이드 프레임워크는 DI를 제공하지 않는다?!
> 안드로이드 공식문서는 DI에 대한 정보를 제공하고 있다.
> [Android의 종속 항목 삽입](https://developer.android.com/training/dependency-injection)
> 또한, `Dagger` 라는 DI를 제공하는 프레임워크도 제공한다
> [Dagger](https://developer.android.com/training/dependency-injection/dagger-basics)