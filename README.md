# Chapter 06. DI(Dependency Injection)와 서비스 로케이터

## 1 어플리케이션 영역과 메인 영역
* 어플리케이션 영역
  * 어플리케이션을 이용해 구현하고자 하는 기능, 목적,처리 등이 존재하는 영역

* 메인(main) 영역
  * 어플리케이션에서 작동할 기능, 목적, 처리 등이 정상적으로 작동하기 위한 Setting 영역 
  * 어플리케이션 영역에서 사용될 객체를 생성한다.
  * 각 객체 간의 의존 관계를 설정한다.
  * 어플리케이션을 실행한다.

## 2 의존관계를 설정하는 방법
### 2- 1 콘크리트 클래스를 직접 사용해서 객체 생성
* 문제점
  * SOLID 개방 페쇄 원칙 위반
  * 의존 역전 원칙 위반
  * 변화에 경직된, 유연하지 못한 코드

### 2-2 DI(의존성 주입) 사용
* 생성자를 이용한 의존 객체 주입
  * 의존 객체를 먼저 생성한 뒤
  * 의존 객체가 필요한 객체에 생성자를 통해 의존 객체를 주입
  * 의존 객체를 먼저 생성할 수 없다면 이용할 수 없는 방법
  * 객체의 불변성 확보 가능
  * 주입하는 객체가 누락된 경우 객체 생성시점에 오류를 발견할 수 있다.

* 설정 메서드 방식
  * 객체를 생성한 이후에 메서드를 통해 의존 객체를 설정하는 방법
  * 의존 객체를 먼저 생성할 수 없다면 이용해야 하는 방법
  * 주입하는 객체가 누락된 경우 객체의 메서드를 실행하는 시점에 Exception 발생
  * 의존 객체의 개수가 많을 경우, 어떤 객체가 의존객체인지 알 기 쉽게 할 수 있음 ( 코드의 가독성이 올라감)

* DI의 장점
  * 단위 TEST에서 장점
    * TEST를 위해 MOCK 객체를  생성할 때,  MOCK 객체의 생성을 위해, 기존 코드를 수정할 필요가 없다
  * 의존성이 줄어든다
    * 의존한다는 것은 그 의존대상의 변화에 취약하다는 것이다.(대상이 변화하였을 때, 이에 맞게 수정해야함) DI로 구현하게 되었을 때, 주입받는 대상이 변하더라도 그 구현 자체를 수정할 일이 없거나 줄어들게됨.
  * 재사용성이 높은 코드가 된다
  * 가독성이 높아진다


### 2-3 서비스 로케이터
* 서비스 로케이터는 어플리케이션에서 필요로 하는 객체를 제공하는 책임을 갖는다.
* 메인 영역에서는 서비스 로케이터가 제공할 객체를 생성하고, 이 객체를 이용해서 서비스 로케이터를 초기화 해준다.

* 객체 등록 방식의 서비스 로케이터
 ![image](https://user-images.githubusercontent.com/58967292/155850906-35d8a27d-a798-409c-8978-4f50ea6e0db0.png)
  * 서비스 로케이터를 생성할 때 사용할 객체를 전달
  * 서비스 로케이터의 인스턴스를 저장하고 참조하기 위한 Static 메서드를 제공
  * 전달해야 할 객체의 수가 많아지면 코드이 가독성을 위해 객체에 별도에 등록 메서드를 제공하는 방식을 선택하는 것이 적절
  * 구현이 쉽다는 장점이 있다
  * 하지만 서비스 로케이터에 객체를 등록하는 인터페이스가 외부에 노출되어 있기 때문에 객체 변경의 위험성이 존재한다

* 상속을 통한 서비스 로케이터
  * 객체를 구하는 추상 메서드를 제공하는 상위 타입 구현
  * 상위 타입을 상속받는 하위 타입에서 사용할 객체 설정
  ![image](https://user-images.githubusercontent.com/58967292/155850862-15face84-4a8e-4e59-8224-2e6349533d8b.png)

* 제네릭.템플릿을 통한 서비스 로케이터
  * 서비스로케이터의 가장 근본적인 단점은 인터페이스 분리 원칙을 위배한다는 것이다
  * 의존 객체가 여러개일 경우,  하나의 의존객체만 수정해도, 서비스로케이터를 사용하는 전체 코드가 재컴파일 되는 상황 발생
  * 간단한 해결방법은 의존 객체별로 서비스 로케이터를 생성해주는 것이지만 이는 코드의 중복이 문제가 됨
  * 따라서 이를 해결할 방법이 제네릭,템플릿을 이용한 서비스 로케이터다
 ```
 public class ServiceLocator {
	private static Map<Class<?>, Object> objectMap = new HashMap<Class<?>, Object>();
	public static <T> T get(Class<T> class) {
		return (T) objectMap.get(class);
	}
	public static void regist(Class<?> class, Object obj) {
		objectMap.put(class, obj);
	}
}
```

* 서비스 로케이터의 단점
  * 동일 타입의 객체가 다수 필요한 경우 각 객체 별로 제공 메서드를 만들어 줘야 함 
  * 이는 콘크리트 클래스에 직접 의존하는 것과 비슷한 효과를 냄 
  * 인터페이스 분리 원칙 위배 
  * 서비스 로케이터를 사용하는 코드 입장에서 서비스 로케이터가 제공하는 다른 타입에 대한 의존이 함께 발생 
  * 이는 다른 의존 객체에 의해서 발생하는 서비스 로케이터 수정 때문에 영향을 받을 수 있다

