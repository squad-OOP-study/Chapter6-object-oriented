## 어플리케이션 영역과 메인 영역

- 어플리케이션 영역
    - 고수준 및 저수준의 구현을 포함한 영역
- 메인 영역
    - 어플리케이션 영역에서 사용될 객체를 생성 / 설정 / 실행한다
    - 각 객체간의 의존 관계를 설정한다.
    - 어플리케이션을 실행한다.

- 의존 관계
    - 모든 의존은 메인에서 어플리케이션 영역으로 향한다.
    - 어플리케이션에서 메인 영역의로의 의존은 존재하지 않는다.
    - 메인 영역을 수정해도 어플리케이션 영역을 수정하지 않아도 된다.

## DI 를 이용한 객체 사용

### DIP 를 지키는 방법

1. 고모듈은 인터페이스에 의존해야한다.
2. 인터페이스를 구현한 콘크리트 클래스에 의존해서는 안되므로 DI(의존성 주입)을 통해 문제를 해결

### DI 방법

1. 생성자 방식
    - 생성 시점에 의존성에 대해서 객체의 정상 동작을 보장할 수 있다.
2. setter 방식
    - 의존 객체의 생성 시점이 미뤄 질 경우 사용하기 적합하다
    - 의존 객채각 많을 경우 가독성을 높일 수 있다.

### DI 와 테스트

- DI 처리는 유닛 테스트에 매우 적합하다.
    - 의존 객체의 미생성 시에도 해당 객체를 mock 객체로 대체하여 의존성에 주입하여 테스트 가능
    - DI 처리가 아닌 경우 내부에 mock 개체나 의존 객체를 생성혹은 찾아내는 코드가 존재하기 때문에 온전히 해당 메서드만의 기능 테스트라고 보기 어려움

## 서비스 로케이터를 이용한 의존 객체 사용

- 안드로이드의 Activity 같이 개발 환경 과 프레임 워크의 젝약으로 DI 사용이 어려울 수 있음
- 서비스 로케이터를 통해 의존 객체를 찾아 낼 수 있음

### 서비스 로케이터의 제작 방법

- 객체 등록 방식(생성자로 전달 방식 , setter , load 초기화 등등)
- 상속을 통한 방식
- 제네릭을 이용한 방식
    - 로케이터안에 다양한 의존 객체에 대한 함수가 존재함
    - 로케이터를 의존함으로써 그 안에 다른 불필요한 의존 객체까지도 의존하게됨(타 객체 수정시 영향 받음) -> 인터페이스 분리법칙 위반
    - 제네릭 기반 로케이터를 통해 해결 가능
    
### 서비스 로케이터의 단점
- 동일 타입의 객체가 다수 필요한 경우 사용 어려움
- 인터페이스 분리 법칙 위반

https://developer.android.com/training/dependency-injection/manual
