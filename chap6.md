# CHAP6 DI와 서비스 로케이터

2022.2.27

> 학습 목표 
- 어플리케이션 영역 : 고수준 정책 및 저수준 구현 영역
- 메인 영역 : 어플리케이션이 동작하도록 각 객체들을 연결해주는 영역
    - 메인영역에서 객체를 연결하기 위해 사용하는 2가지 방법인 DI, 서비스 로케이터에 대해 알아본다. 


## DI를 이용한 의존 객체 사용 
- 사용할 객체를 직접 생성하면 콘크리트 클래스에 대한 의존이 발생한다.
- 콘크리트 클래스를 직접 사용해서 객체 생성하면 의존 역전 원칙을 위반 
- 사용할 객체를 전달받을 수 있는 방법을 제공하면 DI를 적용하기 위한 모든 준비가 끝난다.
  - 예) Worker클래스에 사용할 객체를 전달받을 수 있는 생성자를 추가하는 것으로 DI를 적용할 수 있게 된다.

1. 생성자를 이용해서 의존 객체를 전달 받도록 한다.
2. 메인영역의 Main클래스는 상위수준의 객체가 사용할 객체를 전달한다.    
   즉, main()에서 생성자를 통해 이들이 사용할 객체를 주입한다.
3. DI(의존 주입)을 통해 의존 객체 관리할 때는 객체를 생성하고 각 객체들을 의존 관게에 따라 연결하는 조립기능이 필요하다. 
4. 조립기를 별도로 분리하면 향후에 조립기 구현 변경의 유연함을 얻을 수 있다.
5. 객체조립기능이 분리되면 XML파일을 이용해서 객체 생성과 조립에 대한 정보를 설정하고 XML을 읽어와 초기화 해주도록 구현을 변경할 수 있을 것이다.
   예) **스프링 프레임워크 : 객체 생성, 조립 제공하는 DI프레임워크**

> 의존 객체 전달 방법

1. 생성자 방식
2. 설정 메서드 방식
 - 자바 프로퍼티 규약 : 리턴타입 void, 메서드이름 setXXX()
 - public void configure(JobQueue jobQueue, Transcoder transcoder) 형태도 무방
- 스프링 프레임워크 초기 버젼은 void SetXXX형식 설정 지원, 여러 의존객체 전달하기 위해서는 생성자 방식 사용해야 했다.

<br>

- 각 방식의 장단점
  - 프레임워크가 어떤 방식까지 지원하느냐에 따라 달라진다. 
  - 생성자 방식
    - 의존 객체가 **먼저 생성되어야 있어야** 생성자 방식을 사용할 수 있다. 
    - 필자는 생성자 방식을 선호
    - 객체 생성 시점에 모든 의존 객체 준비 가능하고, 의존 객체가 정상인지 확인할 수 있기 때문.
 - 설정 메서드 방식
   - 객체를 생성한 이후에 의존 객체 설정할 수 있다.
   - 의존 객체가 나중에 생성된다면 설정 메서드 방식 이용해야 한다.
   - 메서드 이름을 통해 어떤 의존 객체가 설정되는지 알 수 있어 코드 가독성 높혀준다.
   - 의존 객체를 setXXX()로 설정한 뒤에 객체 사용 가능하므로, 실수로 설정하지 않았을 경우 실행 과정에서 NullPointerException발생 가능.
  
> DI와 테스트

- 단위테스트 : 한 클래스의 기능을 테스트하는데 초점을 맞춘다.
- DI 적용 시 : 생성자나 설정 메서드 이용해서 Mock 객체를 쉽게 전달할 수 있다.
- DI 미사용 시 : getInstance()라는 의존 객체를 전달하는 메서드가 테스트를 위해 MOCK객체를 전달하도록 잠시 수정해야 한다. 즉, 의존 객체 구현 완료여부가 테스트에 영향을 미친다.
  
> 스프링 프레임워크
- 생성자 방식, 설정 메서드 방식 모두 지원
- 스프링에서 객체 어떻게 생성하고 조립할지 설정 
  - XML 방식
  - 자바 코드 방식
- 스프링 프레임워크가 제공하는 클래스를 이용해서 설정된 객체를 생성, 조립    
    ```java
    //객체 생성, 조립
     ApplicationContext context = new ClassPathXmlAppliationContext(new String[] {"config.xml"});
    //getBean() 메서드로 객체 구해서 원하는 기능 실행 
    Worker worker = (Worker)context.getBean("worker");
    JobCLI jobCLI = (JobCLI) context.getBean("jobCli");
    jobCli.interact();
    worker.run();
    ```
<br>

- 객체 생성, 조립 설정 방식의 장단점
  1. 외부 설정 파일 사용 
    - 의존 객체 변경될 때 마다 자바 코드 수정/컴파일 할 필요 없다.
    - 외부 프로퍼티 파일 참조, 프로퍼티 파일 교체등으로 유연하게 객체 조립 설정 가능.
    - 오타에 취약. 프로그램 실행 시 익셥션으로 판단.
  2. 자바 코드 사용
    - IDE사용 시 오타 문제 쉽게 해결 가능. 문제가 있더라도 컴파일 과정에서 드러난다. 
    - 의존 객체 변경 시 자바 코드 재컴파일 재배포 해줘야 하는 단점

## 서비스 로케이터를 이용한 의존 객체 사용

- 실행환경의 제약 때문에 DI 패턴을 적용할 수 없는 경우 의존 객체를 찾는 다른 방법을 모색해야 한다. 
- 예) 안드로이드 플랫폼 경우, 화면 생성시 Activity클래스 상속 받는다. 이 때 안드로이드 실행 환경은 정해진 메서드만 호출하고, DI 처리를 위한 방법은 제공하지 않는다. 
    ```java
    //프레임워크가 실행해 주지 않음. 즉, DI할 수 없음
    public void setSomeService(Service service){
        this.someService = service
    }
    //안드로이드 프레임워크에 의해 실행됨
    @Override
    public void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }
    ```

> 서비스 로케이터 : 의존 객체를 찾는 다른 방법
- 서비스 로케이터는 어플레이케이션에서 필요로 하는 객체를 제공하는 책임을 갖는다.
- locator.getJobQueue()가 어떤 객체를 리턴해야 할지에 대해 ServiceLocator가 알 수 있어야 한다.
- 서비스 로케이터를 사용하는 경우에도 **메인영역에서 서비스로 케이터가 제공할 객체를 초기화** 해준다. 
- <img src="./그림6-6.jpg" width="60%">

> 서비스 로케이터 구현 방법
1. 객체 등록 방식
    - 서비스 로케이터를 생성할 때 사용할 객체를 전달한다.
    - 서비스 로케이터 인스턴스를 지정하고 참조하기 위한 static 메서드 제공 
    - [리스트6-11,12]코드 이해하기 
    - 구현이 쉽다는 장점 
    - 생성자나 set 메서드를 통해서 서비스 로케이터가 제공할 객체를 등록한 뒤, 사용 코드에서는 서비스 로케이터의 get메서드를 이용해서 사용할 객체를 구하면 된다. 
    - 객체 등록하는 인터페이스가 노출되어 있기 때문에 어플리케이션 영역에서 얼마든지 의존 객체를 바꿀 수 있다. 
      - 객체등록 부분이 public으로 노출되어 있기 때문에 
      - (이건 Lotto클래스 생성을 LottoBundle에서만 하고 싶다고 생각한 부분과 비슷한 부분이다.)
2. 상속을 통한 방식
    - 객체를 구하는 **추상 메서드**를 제공하는 상위 타입 구현
    - 상위 타입을 상속받은 하위 타입에서 사용할 객체 설정
    - ServiceLocator클래스를 상속받은 클래스는 메인영역에 위치. 의존 객체 교체해야 할 때 어플리케이션 영역의 코드 수정 없이 하도록 만든다.
3. 지네릭/템플릿을 이용한 구현
   - 서비스로케이터의 단점은 인터페이스 분리 원칙을 위반한다는 것이다.
   - ServiceLocator를 사용함으로서 자신이 필요한 타입뿐 아니라 서비스로케이터가 제공하는 다른 타입에 대한 의존이 함께 발생한다.
   - 서비스 로케이터를 사용하는 코드가 많아 질수록 의존 객체별로 서비스로케이터를 작성해 줄 수 있지만, 구조가 같은 중복된 Locator클래스들이 생기게 된다. 
   - 이를 해결하기 위해 지네릭을 이용해 서비스로케이터를 구현한다.

> 서비스로케이터 단점
- 동일 타입의 객체가 다수 필요할 경우, 각 객체 별로 제공 메서드를 만들어 주어야 한다. 
- 인터페이스 분리 원칙을 위배한다.
 
   






